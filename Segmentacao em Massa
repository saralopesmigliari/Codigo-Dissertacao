# -*- coding: utf-8 -*-
"""Arquitetura Segmentação em Massa

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XjPREQUeryJMceXrzZhtarT7IEP1eMMG

# **SEGMENTAÇÃO EM MASSA**

As segmentações servem para auxiliar no melhoramento de visualização das imagens para o treinamento.

Aqui, é o processo feito em massa, ja direcionando para diretórios:
"""

from google.colab import drive
drive.mount('/content/drive')

import cv2 # OpenCV
import numpy as np
from matplotlib import pyplot as plt
from google.colab.patches import cv2_imshow
from PIL import Image
from os import listdir
from os.path import isdir
import numpy as np
import matplotlib.pyplot as fig
#from sklearn.model_selection import train_test_split
#from sklearn.preprocessing import LabelEncoder
#from tensorflow.keras.preprocessing.image import ImageDataGenerator #(TÉCNICA PARA AUMENTAR A QUANTIDADE DE IMAGENS QUE JÁ POSSUE)
#from tensorflow.keras.applications import VGG19 #(UM DOS TIPOS DE APLICAÇÕES, UMA CNN JÁ PRONTA)
#from tensorflow.keras.utils import to_categorical
#from keras.layers.convolutional import Conv2D #(CAMADAS DE CONVOLUÇÃO)
#from keras.layers.convolutional import MaxPooling2D #(CAMADAS DE POOLING)
#from tensorflow.keras import layers
#from tensorflow.keras import models
#from tensorflow.keras import optimizers
from sklearn.metrics import classification_report

def select_image(filename): #CARREGA A IMAGEM
    image = Image.open(filename) #ABRE O ARQUIVO
    image = image.convert('RGB') #CONVERTE A IMAGEM PARA RGB
    image = image.resize((299,299)) #REDIMENSIONANDO OS PIXELS DAS IMAGENS

    return np.asarray(image) #VOLTA A IMAGEM COMO UM ARRAY PELA FUNÇÃO DA BIBLIOTECA NUMPY

def load_class(diretorio, classe, imagens, labels): #INTERANDO ARQUIVOS

    for filename in listdir(diretorio):

        path = diretorio + filename

        try:
            imagens.append(select_image(path))
            labels.append(classe)
        except:
            print("Erro ao ler imagem {}".format(path))

    return imagens, labels

def select_data_set(diretorio):

    imagens = list()
    labels = list()

    for subdir in listdir(diretorio):

        path = diretorio + subdir + '/'

        if not isdir(path):
            continue
        imagens, labels = load_class(path, subdir, imagens, labels)

    return imagens, labels

base_dataset = "/content/drive/MyDrive/PROJETO_DANILO/Cassava__mosaic_disease/"
imagens, labels = select_data_set(base_dataset)

def load_class(diretorio, classe, imagens, labels): #INTERANDO ARQUIVOS

    for filename in listdir(diretorio):

        path = diretorio + filename

        try:
            imagens.append(select_image(path))
            labels.append(classe)
        except:
            print("Erro ao ler imagem {}".format(path))

    return imagens, labels

def mostrar(imagem):
  fig = plt.gcf()
  fig.set_size_inches(18,6)
  plt.imshow(cv2.cvtColor(imagem, cv2.COLOR_BGR2RGB), cmap='gray')
  plt.axis('off')
  plt.show()

print(len(imagens))

i = 0
j = len(imagens)
while (i < j):
    imagens[i]
    rgb = cv2.cvtColor(imagens[i], cv2.COLOR_BGR2RGB)
    plt.imshow(rgb);
    gray = cv2.cvtColor(rgb, cv2.COLOR_RGB2GRAY)
    plt.imshow(gray, cmap='gray');
    limiar = 105
    val, thresh = cv2.threshold(gray, limiar, 255, cv2.THRESH_BINARY)
    val
    plt.imshow(thresh, cmap='gray');
    limiar = 105
    val, thresh = cv2.threshold(gray, limiar, 255, cv2.THRESH_BINARY)
    plt.imshow(thresh, cmap = 'gray');
    fig = plt.gcf()
    fig.set_size_inches(18,6)
    plt.imshow(thresh, cmap='gray')
    plt.axis('off')
    plt.show()
    def mostrar(imagem):
      fig = plt.gcf()
      fig.set_size_inches(18,6)
      plt.imshow(cv2.cvtColor(imagem, cv2.COLOR_BGR2RGB), cmap='gray')
      plt.axis('off')
      plt.show()
    mostrar(thresh)
    print(thresh)

    _, thresh = cv2.threshold(gray, limiar, 255, cv2.THRESH_BINARY)

    mostrar(thresh)

    val2, thresh2 = cv2.threshold(gray, limiar, 255, cv2.THRESH_BINARY)
    plt.imshow(thresh2, cmap='gray');
    val2, thresh2 = cv2.threshold(gray, limiar, 255, cv2.THRESH_BINARY)
    plt.imshow(thresh2, cmap = 'gray');
    fig = plt.gcf()
    fig.set_size_inches(18,6)
    plt.imshow(thresh2, cmap='gray')
    plt.axis('off')
    plt.show()
    mostrar(thresh2)
    print(thresh2)

    _, thresh2 = cv2.threshold(gray, limiar, 255, cv2.THRESH_BINARY_INV)

    mostrar(thresh2)

    def exibir_limiarizacao(img, limiar = 130):
       _, thresh_binary = cv2.threshold(gray, limiar, 255, cv2.THRESH_BINARY)
       _, thresh_binary_inv = cv2.threshold(gray, limiar, 255, cv2.THRESH_BINARY_INV)
       _, thresh_trunc = cv2.threshold(gray, limiar, 255, cv2.THRESH_TRUNC)
       _, thresh_to_zero = cv2.threshold(gray, limiar, 255, cv2.THRESH_TOZERO)
       _, thresh_to_zero_inv = cv2.threshold(gray, limiar, 255, cv2.THRESH_TOZERO_INV)

       titulos = ['Imagem original', 'Binary', 'Binary inv', 'Trunc', 'To zero', 'To zero inv']
       imagens = [img, thresh_binary, thresh_binary_inv, thresh_trunc, thresh_to_zero, thresh_to_zero_inv]

       fig = plt.gcf()
       fig.set_size_inches(18,12)

       for i in range(6):
         plt.subplot(2, 3, i + 1)
         plt.imshow(cv2.cvtColor(imagens[i], cv2.COLOR_BGR2RGB), cmap = 'gray')
         plt.title(titulos[i])
         plt.xticks([]),plt.yticks([])
       plt.show()
    exibir_limiarizacao(gray, limiar)
    mostrar(imagens[i])
    gray = cv2.cvtColor(imagens[i], cv2.COLOR_BGR2GRAY)
    valor, otsu = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
    print(valor)
    mostrar(otsu)
    # Nessa célula é aplicado dois valores para se trabalhar, o primeiro para média simples e o segundo com binário
    adapt_media = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, 9) #Tamanho da vizinhança de pixels (matriz 11x11)/ constante que extrai a média ou média ponderada
    mostrar(adapt_media)
    adapt_gauss = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 15, 9)
    # 11 é o tamanho da vizinhança de pixels (matrix 11x11)/  e 9 é a constante que extrai a média ou média ponderada
    mostrar(adapt_gauss)
    adapt_gauss = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 15, 9)
    sobrepor = cv2.add(imagens[i], cv2.cvtColor(adapt_gauss, cv2.COLOR_GRAY2BGR))
    mostrar(sobrepor)#TA AQUI
    cv2.imwrite('/content/drive/MyDrive/PROJETO_DANILO/Falta esses/Binary/Cassava__mosaic_disease/Binaria ('+str(i)+').jpg', thresh)
    cv2.imwrite('/content/drive/MyDrive/PROJETO_DANILO/Falta esses/BinaryInv/Cassava__mosaic_disease/BinariaInv ('+str(i)+').jpg', thresh2)
    cv2.imwrite('/content/drive/MyDrive/PROJETO_DANILO/Falta esses/Mean Adaptative/Cassava__mosaic_disease/Adaptativa_Media ('+str(i)+').jpg', adapt_media)
    cv2.imwrite('/content/drive/MyDrive/PROJETO_DANILO/Falta esses/Gaussian/Cassava__mosaic_disease/Gaussiana ('+str(i)+').jpg', adapt_gauss)
    cv2.imwrite('/content/drive/MyDrive/PROJETO_DANILO/Falta esses/Overlap/Cassava__mosaic_disease/Sobreposicao ('+str(i)+').jpg', sobrepor)
    gray = cv2.cvtColor(rgb, cv2.COLOR_BGR2GRAY)
    valor, otsu = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
    print('Valor de limiar Otsu: ', valor)
    mostrar(otsu)
    valor, otsu = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY | cv2.THRESH_OTSU)
    thresh = cv2.threshold(gray, valor, 255, cv2.THRESH_BINARY) #BINARY
    #result = np.array(thresh)
    thresh2 = cv2.threshold(gray, valor, 255, cv2.THRESH_BINARY_INV) #BINARY_INV
    adapt_media = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 15, 9) #ADAPTATIVA MÉDIA
    adapt_gauss = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 15, 9) #GAUSSIANA
    sobrepor = cv2.add(imagens[i], cv2.cvtColor(adapt_gauss, cv2.COLOR_GRAY2BGR)) #SOBREPOSIÇÃO
    i += 1
else:
  print('Processo finalizado.')
